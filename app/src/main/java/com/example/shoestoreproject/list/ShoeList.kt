package com.example.shoestoreproject.list

//import androidx.test.core.app.ApplicationProvider.getApplicationContext

import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.*
import android.widget.EditText
import android.widget.LinearLayout
import androidx.core.view.get
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.navigation.findNavController
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.navigation.ui.NavigationUI
import com.example.shoestoreproject.R
import com.example.shoestoreproject.databinding.CustomDetailBinding
//import com.example.shoestoreproject.databinding.CustomviewBinding
import com.example.shoestoreproject.databinding.FragmentShoeListBinding
import kotlinx.android.synthetic.main.custom_detail.*
import kotlinx.android.synthetic.main.custom_detail.view.*
import kotlinx.android.synthetic.main.custom_detail.view.companyName_text
import kotlinx.android.synthetic.main.custom_detail.view.constraintLayout
import kotlinx.android.synthetic.main.custom_detail.view.description_text
import kotlinx.android.synthetic.main.custom_detail.view.shoeName_text
import kotlinx.android.synthetic.main.custom_detail.view.shoeSize_text
import kotlinx.android.synthetic.main.fragment_shoe_detail.view.*
import timber.log.Timber


class ShoeList : Fragment() {
    private lateinit var viewModel : ShoeListViewModel
    private lateinit var binding : FragmentShoeListBinding
    private lateinit var customBinding : CustomDetailBinding

    //Q: bindingCustomm is not triggering the returnDetail function
   // private lateinit var bindingCustom : CustomDetailBinding

    //private lateinit var factory : ShoeFactory
    private lateinit var v: View
    private lateinit var myLayout: LinearLayout
    //Q: Need to select views from LinearLayout so I can reference them using the Floating Action Button
    //https://stackoverflow.com/questions/7552333/android-linearlayout-background-selector

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        binding = DataBindingUtil.inflate(
            inflater,
            R.layout.fragment_shoe_list,
            container,
            false
        )
        customBinding = DataBindingUtil.inflate(
            inflater,
            R.layout.custom_detail,
            container,
            false
        )
            /*
        bindingCustom = DataBindingUtil.inflate(
            inflater,
            R.layout.custom_detail,
            container,
            false
        )
        // Set the viewmodel for databinding - this allows the bound layout access to methos in ShoeList
        //this was part of an effort to call a method in ShoeList from the custom_detail.xml but was not necessary after
        //using onClickListener in addCustomView()
        //bindingCustom.shoeListCustom = this
             */

        //Q: Figure out why onCreate and onDestroyView are called twice after navigating from Shoedetail
        //A: Calling Timber.plant() in your onCreate just adds another logger. You can also confirm this by checking
        // how many loggers are running by using Timber.treeCount()
        //Timber.plant(Timber.DebugTree())
        Timber.i("onCreateCalled")

        //adds shoes to the layout
        binding.FABButton.setOnClickListener {view: View? ->  view?.findNavController()?.navigate(R.id.action_shoeList_to_shoeDetail) }

        //Q: Why is the ShoeListArgs object not being generated?
        //A: Build -> Clean Project followed by Build -> Rebuild project builds the objects generated by safeArgs

        //gets argument passed with the navigation command in ShoeDetail
        //val shoeFragmentArgs by navArgs<ShoeListArgs>()
        //factory = ShoeFactory(shoeFragmentArgs.saved)

        //Q: Why is LiveData is reverting to its default value?
        //A: Use requireActivity instead of "this" to ensure that the viewModel is tied to the activity.
        viewModel = ViewModelProvider(requireActivity()).get(ShoeListViewModel::class.java)
        customBinding.customDetail = viewModel
        customBinding.shoeListV = this
        //used to track if navigation is returning from an edit of a shoeDetail view
        viewModel.setReturnFalse()

        //adds each object to the list layout
        viewModel.array.observe(viewLifecycleOwner, Observer { array ->
            if (!array.isEmpty()){
                viewModel.array.value!!.forEachIndexed{ index, element ->
                    viewModel.setId(index)
                    addCustomView(index)
                }
            }
        })

        //lets compiler know that the fragment has an options menu
        setHasOptionsMenu(true)

        return binding.root
    }

    //Q: Not sure why addCustomView requires the (Any) -> Unit
    //A: Unit is equivalent to void in Java. Any is the root class in the Kotlin hierarchy. This is saying the input is any type and the output
    //is a void value
    fun addCustomView(index : Int): (Any) -> Unit {
        //https://stackoverflow.com/questions/6216547/android-dynamically-add-views-into-view
        val vi : LayoutInflater = this.context?.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        v = vi.inflate(R.layout.custom_detail, null)

        //adding a view to the LinearLayout
        //https://stackoverflow.com/questions/2395769/how-to-programmatically-add-views-to-views
        myLayout = binding.linearLayoutId
        v.setLayoutParams(
            LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
        )

        //Q: How to add a viewGroup so that I wont have to create a variable for each textView in the customView layout

        //The textViews act as intermediaries so we can edit the view "v"
        val textViewCompanyName = v.findViewById<View>(R.id.companyName_text) as EditText
        //note: "companyName_text" is synthetic
        textViewCompanyName.companyName_text.setText( viewModel.array.value?.get(index)?._companyName?.value.toString())

        val textViewShoeName = v.findViewById<View>(R.id.shoeName_text) as EditText
        textViewShoeName.shoeName_text.setText(viewModel.array.value?.get(index)?._shoeName?.value.toString())

        val textViewShoeSize = v.findViewById<View>(R.id.shoeSize_text) as EditText
        textViewShoeSize.shoeSize_text.setText(viewModel.array.value?.get(index)?._shoeSize?.value.toString())

        val textViewShoeDescription = v.findViewById<View>(R.id.description_text) as EditText
        textViewShoeDescription.description_text.setText(viewModel.array.value?.get(index)?._shoeDescription?.value.toString())

        val textViewNumStock = v.findViewById<View>(R.id.num_Inventory) as EditText
        textViewNumStock.num_Inventory.setText("Stock: ")
        textViewNumStock.num_Inventory.append(viewModel.array.value?.get(index)?._numStock?.value.toString())

        //creates a button for each view, would be interesting to instead select a view and select an "Edit" button


        v.button.setOnClickListener()
        {
            viewModel.setReturnTrue()
            viewModel.setId(index)
            findNavController().navigate(R.id.action_shoeList_to_shoeDetail)
        }
        // prevents from editing from the shoeList
        v.companyName_text.isFocusable = false
        v.shoeName_text.isFocusable = false
        v.shoeSize_text.isFocusable = false
        v.description_text.isFocusable = false
        v.num_Inventory.isFocusable = false

        myLayout.addView(v)

        //getChildAt() returns the view at the specified position in the group.
       // Log.i("arrayNavigation", this.binding.linearLayoutId.getChildAt(0).id.toString())

        //(Any) -> Unit; requires an expression
        return { print("")}
    }
    //inflates options menu
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.logout_menu, menu)
    }

    //navigates to the id set on the item of the options menu
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return NavigationUI.onNavDestinationSelected(item, requireView().findNavController())
                || super.onOptionsItemSelected(item)
    }
    fun getShoeName(): String
    {
        return viewModel.array.value?.get(viewModel.id.value!!)?._shoeName.toString()
    }
/* alternative method, incomplete
    fun returnToDetail()
    {
        println("Testing")
        viewModel.setReturnTrue()
        findNavController().navigate(R.id.action_shoeList_to_shoeDetail)
    }

 */
}
//Q: Will this refer to the button on the customView?
// A: As shown here, Log.i("arrayConstraintIdReal",v.constraintLayout.id.toString()), we've created a synthetic constraintLayout
//which doesn't really have a use. This layout has not been inflated/initialized as with "v" in addCustomView so it returns a null
// object reference
/*
if (viewModel.saved.value == true){
this.constraintLayout.getViewById(R.id.constraintLayout).button.setOnClickListener {
        view: View? ->  view?.findNavController()?.navigate(R.id.action_shoeList_to_shoeDetail)
}}
 */

